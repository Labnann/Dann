const isBrowser="object"!=typeof process;let fs,w;function addCDNdependencies(){let t=document.createElement("script");t.setAttribute("type","text/javascript"),t.setAttribute("src","https://cdn.jsdelivr.net/npm/mathjs@8.1.0/lib/browser/math.min.js"),document.head.insertBefore(t,document.head.children[0])}function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let r=t.toString(2),o=[],i=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=r.charAt(i);o[t]=""===e?0:JSON.parse(e),i--}return o}function makeBinary(t,e){let r;r=void 0!==e?e:function(t){return t+1};let o=[];for(let e=0;e<Math.pow(2,t)-1;e++){let i=r(e);if(bitLength(i)<=t){let r={input:numberToBinary(e,t),target:numberToBinary(i,t)};o.push(r)}}return o}isBrowser?addCDNdependencies():(fs=require("fs"),require("mathjs"),w=require("@fast-csv/format"));const XOR=[{input:[1,0],output:[1]},{input:[0,1],output:[1]},{input:[0,0],output:[0]},{input:[1,1],output:[0]}];function downloadSTR(t,e){let r="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(t)),o=document.createElement("a");o.setAttribute("href",r),o.setAttribute("download",e+".json"),document.body.appendChild(o),o.click(),o.remove()}function domInput(t,e,r){let o="";void 0!==r&&(o=","+r.toString());let i=document.createElement("input");i.setAttribute("type","file"),i.setAttribute("id","upload"),i.setAttribute("onChange","clickedUpload("+t+o+")");try{void 0!==e?document.getElementById(e).appendChild(i):document.body.appendChild(i)}catch(o){o&&window.addEventListener("load",(function(){domInput(t,e,r)}))}}function upload(t,e,r){try{domInput(t,e,r)}catch(t){console.log(t)}}function clickedUpload(nn,callback){let callfunc=eval(callback),element=document.getElementById("upload"),file=element.files[0],reader=new FileReader,newNN;reader.readAsText(file),reader.onload=function(){if("{"===reader.result[0]){let t=JSON.parse(reader.result);newNN=t,nn.applyToModel(newNN),void 0!==callfunc?callfunc(!1):console.log("Succesfully loaded the file.")}else void 0!==callfunc?callfunc(!0):console.log("Error loading the file.")},reader.onerror=function(){void 0!==callfunc?callfunc(!0):console.log(reader.error)},element.remove()}function sigmoid(t){return 1/(1+exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+exp(-t))}function siLU_d(t){return(1+exp(-t)+t*exp(-t))/pow(1+exp(-t),2)}function tanH(t){return(exp(t)-exp(-t))/(exp(t)+exp(-t))}function tanH_d(t){return 1-pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}DannError=function(t,e){this.msg=t,this.method=e},DannError.prototype.warn=function(){console.warn("DannError: "+this.msg),console.warn("> "+this.method)},DannError.prototype.error=function(){console.error("DannError: "+this.msg),console.error("> "+this.method),console.trace()},DannError.warn=function(t,e){console.warn("DannError: "+t),console.warn("> "+e)},DannError.error=function(t,e){console.error("DannError: "+t),console.error("> "+e),console.trace()};let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d};function mae(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=abs(i-s)}return o=r/i,o}function bce(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=i*log(s)+(1-i)*log(1-s)}return o=-r/i,o}function lcl(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=log(cosh(s-i))}return o=r/i,o}function mbe(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){r+=e[o]-t[o]}return o=r/i,o}function mael(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o]-t[o];r+=-i*(exp(-i)-1)/(exp(-i)+1)}return o=r/i,o}function rmse(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=pow(i-s,2)}return o=sqrt(r/i),o}function mce(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=pow(abs(i-s),3)}return o=r/i,o}function mse(t,e){let r=0,o=0,i=e.length;for(let o=0;o<i;o++){let i=e[o],s=t[o];r+=pow(i-s,2)}return o=r/i,o}let lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael};const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),pow=(t,e)=>Math.pow(t,e),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2;function max(t){let e=0,r=t.length;for(let o=0;o<r;o++)t[o]>e&&(e=t[o]);return e}function min(t){let e=1/0,r=t.length;for(let o=0;o<r;o++)t[o]<e&&(e=t[o]);return e}function avg(t){let e=0,r=t.length;for(let o=0;o<r;o++)e+=t[o];return e/r}let poolfuncs={max:max,min:min,avg:avg};Matrix=function(t=0,e=0){this.rows=t,this.cols=e;let r=[[]];for(let o=0;o<t;o++){r[o]=[];for(let t=0;t<e;t++)r[o][t]=0}this.matrix=r},Matrix.prototype.add=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.add");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t;return this},Matrix.add=function(t,e){let r=new Matrix(t.rows,t.cols);if(t.rows===e.rows&&t.cols===e.cols){for(let o=0;o<r.rows;o++)for(let i=0;i<r.cols;i++)r.matrix[o][i]=t.matrix[o][i]+e.matrix[o][i];return r}DannError.error("Matrix dimensions should match","Matrix.addition")},Matrix.prototype.addPercent=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let o=this.matrix[e][r];this.matrix[e][r]+=o*t}},Matrix.prototype.addRandom=function(t,e){let r=Matrix.make(this.rows,this.cols);if(e<=0||e>1)DannError.error("Probability argument must be between 0 and 1","Matrix.prototype.addRandom");else for(let o=0;o<this.rows;o++)for(let i=0;i<this.cols;i++){let s=this.matrix[o][i];random(0,1)<e&&(r[o][i]=s+s*random(-t,t))}this.set(r)},Matrix.fromArray=function(t){let e=new Matrix(t.length,1);for(let r=0;r<t.length;r++)e.matrix[r][0]=t[r];return e},Matrix.prototype.initiate=function(t=0){if(void 0===t);else{if("number"==typeof t){for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix[e].length;r++)this.matrix[e][r]=t;return this}DannError.error("The value entered as an argument is not a number","Matrix.prototype.initiate")}},Matrix.prototype.insert=function(t,e,r){if("number"==typeof t)if("number"==typeof e){if("number"==typeof r)return e<this.cols&&r<this.rows?(this.matrix[e][r]=t,this):void DannError.error(" x, y arguments exceed the matrix dimensions.","Matrix.prototype.insert");DannError.error('Expected Number for "y" argument',"Matrix.prototype.insert")}else DannError.error('Expected Number for "x" argument',"Matrix.prototype.insert");else DannError.error('Expected Number for "value" argument',"Matrix.prototype.insert")},Matrix.prototype.log=function(t){let e=0,r=!1;void 0!==t&&(t.decimals&&(e=pow(10,t.decimals)),t.table&&(r=t.table));let o=new Matrix(this.rows,this.cols);if(o.set(this.matrix),0===e)for(let t=0;t<this.rows;t++)for(let r=0;r<this.cols;r++){let i=this.matrix[t][r];o.insert(round(i*e)/e,r,t)}r?console.table(o.matrix):console.log(o)},Matrix.make=function(t=0,e=0){let r=[[]];for(let o=0;o<t;o++){r[o]=[];for(let t=0;t<e;t++)r[o][t]=0}return r},Matrix.prototype.map=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let o=this.matrix[e][r];this.matrix[e][r]=t(o)}return this},Matrix.map=function(t,e){if(t instanceof Matrix){for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++){let i=t.matrix[r][o];t.matrix[r][o]=e(i)}return t}DannError.error("First argument must be an instance of Matrix","Matrix.map")},Matrix.prototype.mult=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.multiplication","Matrix.prototype.mult");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t;return this},Matrix.mult=function(t,e,r={mode:"cpu"}){if(void 0!==r&&r.mode&&(mode=r.mode),"cpu"===mode){let r=new Matrix(t.rows,e.cols);if(t instanceof Matrix&&e instanceof Matrix){if(t.cols!==e.rows)return void DannError.error("The rows of B must match the columns of A","Matrix.mult");for(let o=0;o<r.rows;o++)for(let i=0;i<r.cols;i++){let s=0;for(let r=0;r<t.cols;r++)s+=t.matrix[o][r]*e.matrix[r][i];r.matrix[o][i]=s}return r}}else DannError.error("mode specified is not valid","Matrix.prototype.mult")},Matrix.prototype.randomize=function(t,e){for(let r=0;r<this.matrix.length;r++)for(let o=0;o<this.matrix[r].length;o++)this.matrix[r][o]=random(t,e);return this},Matrix.prototype.set=function(t){"number"==typeof t.length&&"number"==typeof t[0].length&&"object"==typeof t?(this.matrix=t,this.rows=t.length,this.cols=t[0].length):DannError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]","Matrix.prototype.set")},Matrix.prototype.sub=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.sub");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t;return this},Matrix.sub=function(t,e){if(t instanceof Matrix&&e instanceof Matrix){if(t.rows!==e.rows||t.cols!==e.cols)return void DannError.error("The matrix dimensions should match","Matrix.sub");{let r=new Matrix(t.rows,t.cols);for(let o=0;o<r.rows;o++)for(let i=0;i<r.cols;i++)r.matrix[o][i]=t.matrix[o][i]-e.matrix[o][i];return r}}DannError.error("The arguments should be p5.MatrixTensors","Matrix.sub")},Matrix.prototype.toArray=function(){let t=[];if(1===this.cols){for(let e=0;e<this.rows;e++)t[e]=this.matrix[e][0];return t}return 1===this.rows?(t=this.matrix[0],t):void DannError.error("None of the lengths of the matrix equal 1","Matrix.prototype.toArray")},Matrix.toArray=function(t){let e=[];if(1===t.cols){for(let r=0;r<t.rows;r++)e[r]=t.matrix[r][0];return e}return 1===t.rows?(e=t.matrix[0],e):void DannError.error("None of the lengths of the matrix equal 1","Matrix.toArray")},Matrix.transpose=function(t){let e=new Matrix(t.cols,t.rows);for(let r=0;r<t.rows;r++)for(let o=0;o<t.cols;o++)e.matrix[o][r]=t.matrix[r][o];return e},Layer=function t(e,r,o,i,s,n){if(this.type=e,this.subtype=this.getSubtype(),"pool"!==this.subtype)"hidden"===this.type||"output"===this.type?(this.size=r,this.setFunc(o),this.layer=new Matrix(this.size,1)):"input"===this.type&&(this.size=r,this.layer=new Matrix(this.size,1));else if("pool"===this.subtype){if(this.stride=i,this.sampleSize=o,this.inputSize=r,void 0!==s&&void 0!==n)this.sizeX=s,this.sizeY=n;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=t.getPoolOutputLength(o,i,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,a=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&a!==Math.floor(a))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=this.getPrefix(),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(e,r,o){this.input=Matrix.fromArray(e);let i=t.selectPools(e,r,o,this.sizeX,this.sizeY),s=[];for(let t=0;t<i.length;t++)s[t]=this.poolfunc(i[t]);return this.layer=Matrix.fromArray(s),s}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())},Layer.prototype.feed=function(t,e){if("pool"===this.subtype){let r=!1,o=!1,i=this.sampleSize,s=this.stride;if(void 0!==e&&(e.log&&(r=e.log),e.table&&(o=e.table)),t.length!==this.inputSize)return void DannError.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has.","Layer.prototype.feed");{let e=this.downsample(t,i,s);return r&&(o?console.table(e):console.log(e)),e}}DannError.error("This function can only be used by Layers with 'pool' subtype","Layer.prototype.feed")},Layer.getPoolOutputLength=function(t,e,r,o){return((r-t)/e+1)*((o-t)/e+1)},Layer.getSqIndex=function(t,e,r){return t*r+e},Layer.prototype.log=function(){console.log(this)},Layer.selectPools=function(t,e,r,o,i){t.length;if(o!==Math.floor(o))return;if(o/r!==Math.floor(o/r))return;let s=[];for(let n=0;n+e<=i;n+=r)for(let i=0;i+e<=o;i+=r){let r=[];for(let s=0;s<e;s++)for(let a=0;a<e;a++)r.push(t[Layer.getSqIndex(o,a+i,s+n)]);s.push(r)}return s},Layer.prototype.setFunc=function(t){let e=Layer.stringTofunc(t);void 0!==e?(this.actname=e.name,this.actname_d=e.name_d,this.actfunc=e.func,this.actfunc_d=e.func_d):DannError.error("Bad activation information","Layer.prototype.setFunc")},Layer.stringTofunc=function(t){let e,r,o=t,i=o+"_d";return isBrowser?(e=window[o],r=window[i]):(e=activations[o],r=activations[i]),void 0!==e?void 0!==r?{name:o,name_d:i,func:e,func_d:r}:void DannError.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc"):void DannError.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc")},Layer.prototype.getPrefix=function(){let t=this.type,e=t.length;return t.slice(0,e-4)},Layer.prototype.getSubtype=function(){let t=this.type,e=t.length,r=t.slice(e-4,e);return"pool"===r?r:t},Dann=function(t=1,e=1){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.outs=[],this.loss=0,this.losses=[],this.lr=.001,this.arch=[t,e],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name},Dann.prototype.addHiddenLayer=function(t,e){void 0!==e?void 0===activations[e]&&("string"==typeof e&&DannError.error("'"+e+"' is not a valid activation function, as a result, the activation function was set to 'sigmoid'.","Dann.prototype.addHiddenLayer"),e="sigmoid"):e="sigmoid",this.arch.splice(this.arch.length-1,0,t);let r=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,r)},Dann.prototype.backpropagate=function(t,e,r){let o=!1,i="cpu",s=!1,n=!1;void 0!==r&&(o=void 0!==r.log&&r.log,void 0!==r.table&&(n=r.table),void 0!==r.mode?(i=r.mode,"gpu"===i&&console.log("gpu version coming soon")):i="cpu",s=void 0===r.saveLoss||r.saveLoss);let a=new Matrix(0,0);if(e.length!==this.o)return console.error("Dann Error: The target array length does not match the number of ouputs the dannjs model has."),void console.trace();if(a=Matrix.fromArray(e),"number"!=typeof this.lr)return console.error("Dann Error: The learning rate specified (Dann.lr property) is not a number."),void console.trace();this.outs=this.feedForward(t,{log:!1,mode:i}),this.errors[this.errors.length-1]=Matrix.sub(a,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr);for(let t=this.weights.length-1;t>0;t--){let e=Matrix.transpose(this.Layers[t].layer),r=Matrix.mult(this.gradients[t],e);this.weights[t].add(r),this.biases[t].add(this.gradients[t]);let o=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.mult(o,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d),this.gradients[t-1].mult(this.errors[t-1]),this.gradients[t-1].mult(this.lr)}let l=Matrix.transpose(this.Layers[0].layer),h=Matrix.mult(this.gradients[0],l);this.weights[0].add(h),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e),!0===s&&this.losses.push(this.loss),!0===o&&(console.log("Prediction: "),n?console.table(this.outs):console.log(this.outs),console.log("target: "),n?console.table(e):console.log(e),console.log("Loss: ",this.loss))},Dann.createFromJSON=function(t){const e=new Dann;return e.fromJSON(t),e},Dann.prototype.feedForward=function(t,e){let r=!1,o="cpu",i=!1,s=!1,n=1e3;if(void 0!==e&&(r=void 0!==e.log&&e.log,void 0!==e.decimals&&(e.decimals>21&&(DannError.warn("Maximum number of decimals is 21, was set to 21 by default.","Dann.prototype.feedForward"),e.decimals=21),n=pow(10,e.decimals),s=!0),void 0!==e.table&&(i=e.table),void 0!==e.mode?(o=e.mode,"gpu"===o&&(DannError.warn("Gpu Support not available yet, mode set to 'cpu'","Dann.prototype.feedForward"),o="cpu")):o="cpu"),t.length!==this.i){for(let t=0;t<this.o;t++)this.outs[t]=0;return DannError.error("The input array length does not match the number of inputs the dannjs model has.","Dann.prototype.feedForward"),this.outs}this.Layers[0].layer=Matrix.fromArray(t),0===this.weights.length&&(DannError.warn("The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers.","Dann.prototype.feedForward"),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],r=this.Layers[t+1];r.layer=Matrix.mult(this.weights[t],e.layer),r.layer.add(this.biases[t]),r.layer.map(r.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let a=this.outs;return!0===r&&(!0===s&&(a=a.map((t=>round(t*n)/n))),!0===i?(console.log("Prediction: "),console.table(a)):(console.log("Prediction: "),console.log(a))),a},Dann.prototype.fromJSON=function(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let r=JSON.parse(e[t]),o=new Layer(r.type,r.size,r.actname);this.Layers[t]=o}this.makeWeights();let r=JSON.parse(t.wstr);for(let t=0;t<r.length;t++)this.weights[t].set(JSON.parse(r[t]));let o=JSON.parse(t.bstr);for(let t=0;t<o.length;t++)this.biases[t].set(JSON.parse(o[t]));let i=JSON.parse(t.estr);for(let t=0;t<i.length;t++)this.errors[t].set(JSON.parse(i[t]));let s=JSON.parse(t.gstr);for(let t=0;t<s.length;t++)this.gradients[t].set(JSON.parse(s[t]));return this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),this.loss=t.loss,this.losses=[],this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,this},Dann.prototype.load=function(t,e,r){if(isBrowser)upload(t,e,r);else{let r="./savedDanns/"+t+"/dannData.json";if(fs.existsSync(r)){let t=fs.readFileSync(r,"utf8"),o=JSON.parse(t);if(this.applyToModel(o),"function"!=typeof e){let t=typeof e;return void DannError.error("callback specified is not a function, the function recieved a '"+t+"' instead","Dann.prototype.load")}e(!1)}else{if("function"!=typeof e){if("function"!=typeof e){let t=typeof e;return void DannError.error("Callback specified is not a function, the function recieved a "+t+" instead","Dann.prototype.load")}return void DannError.error("File not found","Dann.prototype.load")}e(!0)}}},Dann.prototype.log=function(t){let e=!1,r=!1,o=!1,i=!1,s=!1,n=!1,a=!1,l=!1,h=1e3;if(void 0!==t){if(t.weights&&(e=t.weights),t.gradients&&(r=t.gradients),t.errors&&(o=t.errors),t.biases&&(i=t.biases),t.struct&&(s=t.struct),t.misc&&(n=t.misc),t.table&&(l=t.table),t.layers&&(a=t.layers,s=t.layers),t.details){let l=t.details;r=l,e=l,o=l,i=l,s=l,n=l,a=l}t.decimals&&(t.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),t.decimals=21),h=pow(10,t.decimals))}else s=!0,n=!0;if(0===this.weights.length&&this.makeWeights(),(void 0===t||void 0!==t&&!0===t.details)&&console.log("Dann NeuralNetwork:"),s){console.log("Layers:");for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t],r=e.type+" Layer: ",o="";0===t?(r="Input Layer:   ",o="       "):t===e.length-1?(r="Output Layer:  ",o="  ("+e.actname+")"):o="  ("+e.actname+")",console.log("\t"+r+e.size+o),a&&console.log(this.Layers[t])}}if(o){console.log("Errors:");for(let t=0;t<this.errors.length;t++){let e=Matrix.toArray(this.errors[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}if(r){console.log("Gradients:");for(let t=0;t<this.gradients.length;t++){let e=Matrix.toArray(this.gradients[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}if(e){console.log("Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:l})}}if(i){console.log("Biases:");for(let t=0;t<this.biases.length;t++){let e=Matrix.toArray(this.biases[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}n&&(console.log("Other Values: "),console.log("\tLearning rate: "+this.lr),console.log("\tLoss Function: "+this.lossfunc.name),console.log("\tCurrent Epoch: "+this.epoch),console.log("\tLatest Loss: "+this.loss)),console.log(" ")},Dann.prototype.makeWeights=function(t,e){let r=-1,o=1;void 0!==t&&void 0!==e&&(r=t,o=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],i=this.Layers[t+1],s=new Matrix(i.layer.rows,e.layer.rows),n=new Matrix(i.layer.rows,1);s.randomize(r,o),n.randomize(1,-1),this.weights[t]=s,this.biases[t]=n,this.errors[t]=new Matrix(i.layer.rows,1),this.gradients[t]=new Matrix(i.layer.rows,1),void 0===i.actfunc&&i.setFunc("sigmoid")}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}},Dann.prototype.mutateAdd=function(t){if("number"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].addPrecent(t);else DannError.error("randomFactor argument must be a number.","Dann.prototype.mutateAdd")},Dann.prototype.mutateRandom=function(t,e){if("number"==typeof t){if(void 0!==e){if("number"!=typeof e)return void DannError.error("Probability argument must be a number.","Dann.prototype.mutateRandom")}else e=1;for(let r=0;r<this.weights.length;r++)this.weights[r].addRandom(t,e)}else DannError.error("Range argument must be a number.","Dann.prototype.mutateRandom")},Dann.prototype.outputActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation");this.Layers[this.Layers.length-1].setFunc(t)},Dann.prototype.save=function(t,e){let r,o=!1,i=!1,s=0,n="none";if(void 0!==e&&(void 0!==e.report&&(i=e.report),void 0!==e.test))if("function"==typeof e.test){s=100*(0,e.test)(),n=s+"%"}else console.error("Dann Error: the test option can only be a function."),console.trace();let a=this.dataObject();if(isBrowser)downloadSTR(a,t);else{if(r="./savedDanns/"+t+"/dannData.json",fs.existsSync(r)&&(o=!0),fs.existsSync("./savedDanns")||fs.mkdirSync("./savedDanns"),fs.existsSync("./savedDanns/"+t)||fs.mkdirSync("./savedDanns/"+t),!0===i){let r=[];for(let t=1;t<this.arch.length;t++)r[t-1]=this.Layers[t].actname;let o=[];o.push(["Dann","train report"]),o.push(["Arch: ",this.arch]),o.push(["Acts: ",r]),o.push(["Lr: ",this.lr]),o.push(["Epoch:",this.epoch]),"function"==typeof e.test&&o.push(["Accuracy:",n]),o.push(["Index","AvgLoss"]);for(let t=0;t<this.losses.length;t++)o.push([t+1,this.losses[t]]);w.writeToPath("./savedDanns/"+t+"/report.csv",o).on("error",(t=>console.error(t))).on("finish",(()=>console.log("saved training report at ./savedDanns/"+t+"/report.csv")))}fs.writeFileSync(r,JSON.stringify(a)),!0===o?(console.log("[32m",""),this.log(),console.log("Succesfully overwritten the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m","")):(console.log("[32m",""),this.log(),console.log("Succesfully saved the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m",""))}},Dann.prototype.setLossFunction=function(t){let e=lossfuncs[t];if(void 0===e)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Dann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Dann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=e},Dann.prototype.toJSON=function(){let t=[];for(let e=0;e<this.weights.length;e++)t[e]=JSON.stringify(this.weights[e].matrix);let e=JSON.stringify(t),r=[];for(let t=0;t<this.Layers.length;t++)r[t]=JSON.stringify(this.Layers[t]);let o=JSON.stringify(r),i=[];for(let t=0;t<this.biases.length;t++)i[t]=JSON.stringify(this.biases[t].matrix);let s=JSON.stringify(i),n=[];for(let t=0;t<this.errors.length;t++)n[t]=JSON.stringify(this.errors[t].matrix);let a=JSON.stringify(n),l=[];for(let t=0;t<this.gradients.length;t++)l[t]=JSON.stringify(this.gradients[t].matrix);return{wstr:e,lstr:o,bstr:s,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch}},isBrowser||(module.exports={dann:Dann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeBinary:makeBinary});