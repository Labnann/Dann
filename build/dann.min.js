const isBrowser="object"!=typeof process;let csv,fs,w;function addCDNdependencies(){let t=document.createElement("script");t.setAttribute("type","text/javascript"),t.setAttribute("src","https://cdn.jsdelivr.net/npm/mathjs@8.1.0/lib/browser/math.min.js"),document.head.insertBefore(t,document.head.children[0])}function downloadSTR(t,e){let s="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(t)),o=document.createElement("a");o.setAttribute("href",s),o.setAttribute("download",e+".json"),document.body.appendChild(o),o.click(),o.remove()}function upload(t){let e=document.createElement("input");e.setAttribute("type","file"),e.setAttribute("id","upload"),e.setAttribute("onChange","clickedUpload("+t+")"),document.body.appendChild(e)}function clickedUpload(t){let e,s=document.getElementById("upload"),o=s.files[0],r=new FileReader;r.readAsText(o),r.onload=function(){let s=JSON.parse(r.result);e=s,t.applyToModel(e)},r.onerror=function(){console.log(r.error)},s.remove()}isBrowser?addCDNdependencies():(fs=require("fs"),require("mathjs"),csv=require("fast-csv"),w=require("@fast-csv/format"));const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),logn=(t,e)=>log(t)/log(e),pow=(t,e)=>Math.pow(t,e),sin=t=>Math.sin(t),cos=t=>Math.cos(t),tan=t=>Math.tan(t),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2,sech=t=>1/cosh(t);function sigmoid(t){return 1/(1+exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+exp(-t))}function siLU_d(t){return(1+exp(-t)+t*exp(-t))/pow(1+exp(-t),2)}function tanH(t){return(exp(t)-exp(-t))/(exp(t)+exp(-t))}function tanH_d(t){return 1-pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function linear(t){return t}function linear_d(t){return 1}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}function mae(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=abs(r-i)}return o=s/r,o}function bce(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=r*log(i)+(1-r)*log(1-i)}return o=-s/r,o}function lcl(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=log(cosh(i-r))}return o=s/r,o}function mbe(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){s+=e[o]-t[o]}return o=s/this.o,o}function rmse(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=pow(r-i,2)}var i;return i=s/r,o=Math.sqrt(i),o}function mce(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=pow(abs(r-i),3)}return o=s/r,o}function mse(t,e){let s=0,o=0,r=e.length;for(let o=0;o<r;o++){let r=e[o],i=t[o];s+=pow(r-i,2)}return o=s/r,o}function max(t){let e=0,s=t.length;for(let o=0;o<s;o++)t[o]>e&&(e=t[o]);return e}function min(t){let e=1e5,s=t.length;for(let o=0;o<s;o++)t[o]<e&&(e=t[o]);return e}function avg(t){let e=0,s=t.length;for(let o=0;o<s;o++)e+=t[o];return e/s}class Matrix{constructor(t,e){this.rows=t,this.cols=e,this.matrix=Matrix.make(t,e)}static toArray(t){let e=[];if(1==t.cols)for(let s=0;s<t.rows;s++)e[s]=t.matrix[s][0];return e}static fromArray(t){let e=new Matrix(t.length,1);for(let s=0;s<t.length;s++)e.matrix[s][0]=t[s];return e}static transpose(t){let e=new Matrix(t.cols,t.rows);for(let s=0;s<t.rows;s++)for(let o=0;o<t.cols;o++)e.matrix[o][s]=t.matrix[s][o];return e}static map(t,e){for(let s=0;s<t.rows;s++)for(let o=0;o<t.cols;o++){let r=t.matrix[s][o];t.matrix[s][o]=e(r)}return t}static addition(t,e){let s=t,o=e,r=new Matrix(s.rows,s.cols);if(s.rows===o.rows&&s.cols===o.cols){for(let t=0;t<r.rows;t++)for(let e=0;e<r.cols;e++)r.matrix[t][e]=s.matrix[t][e]-o.matrix[t][e];return r}}static subtract(t,e){let s=t,o=e,r=new Matrix(s.rows,s.cols);if(s instanceof Matrix&&o instanceof Matrix)for(let t=0;t<r.rows;t++)for(let e=0;e<r.cols;e++)r.matrix[t][e]=s.matrix[t][e]-o.matrix[t][e];return r}static multiply(t,e,s){let o="cpu";if(void 0!==s&&s.mode&&(o=s.mode),"cpu"!=o)return"gpu"==o?(console.log("gpu coming soon"),o="cpu",Matrix.multiply(t,e)):(console.error("Dann Error: mode specified is not valid"),void console.trace());{let s=t,o=e,r=new Matrix(s.rows,o.cols);if(t instanceof Matrix&&e instanceof Matrix){if(s.cols!==o.rows)return console.log(s,o),console.error("not compatible"),void console.trace();for(let t=0;t<r.rows;t++)for(let e=0;e<r.cols;e++){let i=0;for(let r=0;r<s.cols;r++)i+=s.matrix[t][r]*o.matrix[r][e];r.matrix[t][e]=i}return r}}}static make(t,e){let s=[];for(let o=0;o<t;o++){s[o]=[];for(let t=0;t<e;t++)s[o][t]=0}return s}insert(t,e,s){return"number"!=typeof t?(console.error('Dann error: first "value" argument is not a number'),void console.trace()):"number"!=typeof e?(console.error('Dann error: second "x" argument is not a number'),void console.trace()):"number"!=typeof s?(console.error('Dann error: third "y" argument is not a number'),void console.trace()):void(e<this.cols&&s<this.rows?this.matrix[s][e]=t:(console.error("Dann error: x,y arguments exceed the matrix dimensions."),console.trace()))}addRandom(t,e){for(let s=0;s<this.rows;s++)for(let o=0;o<this.cols;o++){let r=this.matrix[s][o];random(0,1)<e&&(this.matrix[s][o]+=r*random(-t,t))}}addPrecent(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){let o=this.matrix[e][s];this.matrix[e][s]+=o*t}}set(t){if("number"!=typeof t.length||"number"!=typeof t[0].length||"object"!=typeof t)return console.error("Dann error: the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]"),void console.trace();this.matrix=t,this.rows=t.length,this.cols=t[0].length}add(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return;for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]+=t.matrix[e][s]}else for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]+=t}sub(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]-=t}mult(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void console.log("rows of A must match rows of B");for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]*=t.matrix[e][s]}else for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++)this.matrix[e][s]*=t}log(t){let e=1e3,s=!1;void 0!==t&&(t.decimals&&(e=pow(10,t.decimals)),t.table&&(s=t.table));let o=new Matrix(this.rows,this.cols);for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++){let r=this.matrix[t][s];o.insert(round(r*e)/e,s,t)}s?console.table(o.matrix):console.log(o)}initiate(t){let e=0;if(void 0!==t){if("number"!=typeof t)return console.error("Dann error: the value entered as an argument is not a number"),void console.trace();e=t}for(let t=0;t<this.matrix.length;t++)for(let s=0;s<this.matrix[t].length;s++)this.matrix[t][s]=e}map(t){for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){let o=this.matrix[e][s];this.matrix[e][s]=t(o)}}randomize(t,e){for(let s=0;s<this.matrix.length;s++)for(let o=0;o<this.matrix[s].length;o++)this.matrix[s][o]=random(t,e)}}class Layer{constructor(t,e,s,o,r,i){if(this.type=t,this.subtype=Layer.getSubtype(t),"hidden"==this.type||"output"==this.type){this.size=e;let t=Layer.stringTofunc(s);this.setFunc(t),this.layer=new Matrix(this.size,1)}else if("input"==this.type)this.size=e,this.layer=new Matrix(this.size,1);else if("pool"==this.subtype){if(this.stride=o,this.sampleSize=s,this.inputSize=e,void 0!==r&&void 0!==i)this.sizeX=r,this.sizeY=i;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=Layer.getPoolOutputLength(e,s,o,this.sizeX,this.sizeY);let t=this.inputSize/this.sizeX,n=this.inputSize/this.sizeY;if(t!==Math.floor(t)&&n!==Math.floor(n))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1);let a=Layer.getPrefix(this.type,4);this.pickFunc=poolfuncs[a],this.downsample=function(t,e,s){this.input=Matrix.fromArray(t);let o=Layer.selectPools(t,e,s,this.sizeX,this.sizeY),r=[];for(let t=0;t<o.length;t++)r[t]=this.pickFunc(o[t]);return this.layer=Matrix.fromArray(r),r},this.feed=function(t,e){let s=!1,o=!1,r=this.sampleSize,i=this.stride;if(void 0!==e&&(e.log&&(s=e.log),e.table&&(o=e.table)),t.length!==this.inputSize)return console.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has."),void console.trace();{let e=this.downsample(t,r,i);return s&&(o?console.table(e):console.log(e)),e}}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())}static stringTofunc(t){let e,s,o=t,r=o+"_d";if(isBrowser?(e=window[o],s=window[r]):(e=activations[o],s=activations[r]),void 0!==e)return void 0!==s?{name:o,name_d:r,func:e,func_d:s}:(console.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'."),void console.trace());console.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'."),console.trace()}static getPrefix(t,e){let s=t.length;return t.slice(0,s-4)}static getSubtype(t){let e=t.length,s=t.slice(e-4,e);return"pool"==s?s:t}static getSqIndex(t,e,s){return t*s+e}static selectPools(t,e,s,o,r){t.length;if(o!==Math.floor(o))return;if(o/s!==Math.floor(o/s))return;let i=[];for(let n=0;n+e<=r;n+=s)for(let r=0;r+e<=o;r+=s){let s=[];for(let i=0;i<e;i++)for(let a=0;a<e;a++)s.push(t[Layer.getSqIndex(o,a+r,i+n)]);i.push(s)}return i}static getPoolOutputLength(t,e,s,o,r){return((o-e)/s+1)*((r-e)/s+1)}setAct(t){let e=Layer.stringTofunc(t);this.setFunc(e)}setFunc(t){void 0!==t&&(this.actname=t.name,this.actname_d=t.name_d,this.actfunc=t.func,this.actfunc_d=t.func_d)}log(){console.log(this)}}class Dann{constructor(t,e){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.outs=[],this.loss=0,this.losses=[],this.lr=.001,this.arch=[],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name}setLossFunction(t){let e=lossfuncs[t];if(null==e)return"string"==typeof t?(console.error("Dann Error: '"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default."),void console.trace()):(console.error("Dann Error: Did not detect string value, as a result, the loss function is set to 'mse' by default."),void console.trace());this.lossfunc_s=t,this.lossfunc=e}outputActivation(t){if(null==activations[t]&&!isBrowser)return"string"==typeof t?(console.error("Dann Error: '"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),void console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),void console.trace());this.Layers[this.Layers.length-1].setAct(t)}makeWeights(t,e){let s=-1,o=1;void 0!==t&&void 0!==e&&(s=t,o=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],r=this.Layers[t+1],i=new Matrix(r.layer.rows,e.layer.rows),n=new Matrix(r.layer.rows,1);if(i.randomize(s,o),n.randomize(1,-1),this.weights[t]=i,this.biases[t]=n,this.errors[t]=new Matrix(r.layer.rows,1),this.gradients[t]=new Matrix(r.layer.rows,1),null==r.actfunc){let t=Layer.stringTofunc("sigmoid");r.setFunc(t)}}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}}addHiddenLayer(t,e){null!=activations[e]||isBrowser||("string"==typeof e?(console.error("Dann Error: '"+e+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),console.trace()),e="sigmoid");let s=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,s)}feedForward(t,e){let s=!1,o="cpu",r=!1;if(void 0!==e&&(s=void 0!==e.log&&e.log,void 0!==e.table&&(r=e.table),void 0!==e.mode?(o=e.mode,"gpu"==o&&(console.warn("Gpu support in the works."),o="cpu")):o="cpu"),t.length!=this.i){for(let t=0;t<this.o;t++)this.outs[t]=0;return console.error("Dann Error: The input array length does not match the number of inputs the dannjs model has."),console.trace(),this.outs}this.Layers[0].layer=Matrix.fromArray(t),0===this.weights.length&&(console.error("Dann Error: The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers."),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],s=this.Layers[t+1];s.layer=Matrix.multiply(this.weights[t],e.layer),s.layer.add(this.biases[t]),s.layer.map(s.actfunc)}return this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),1==s&&(1==r?(console.log("Prediction: "),console.table(this.outs)):console.log("Prediction: ",this.outs)),this.outs}backpropagate(t,e,s){let o=!1,r="cpu",i=!1,n=!1;void 0!==s&&(o=void 0!==s.log&&s.log,void 0!==s.table&&(n=s.table),void 0!==s.mode?(r=s.mode,"gpu"==r&&console.log("gpu version coming soon")):r="cpu",i=void 0===s.saveLoss||s.saveLoss);let a=new Matrix(0,0);if(e.length!=this.o)return console.error("Dann Error: The target array length does not match the number of ouputs the dannjs model has."),void console.trace();if(a=Matrix.fromArray(e),"number"!=typeof this.lr)return console.error("Dann Error: The learning rate specified (Dann.lr property) is not a number."),void console.trace();this.outs=this.feedForward(t,{log:!1,mode:r}),this.errors[this.errors.length-1]=Matrix.subtract(a,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr);for(let t=this.weights.length-1;t>0;t--){let e=Matrix.transpose(this.Layers[t].layer),s=Matrix.multiply(this.gradients[t],e);this.weights[t].add(s),this.biases[t].add(this.gradients[t]);let o=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.multiply(o,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d),this.gradients[t-1].mult(this.errors[t-1]),this.gradients[t-1].mult(this.lr)}let l=Matrix.transpose(this.Layers[0].layer),h=Matrix.multiply(this.gradients[0],l);this.weights[0].add(h),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e),1==i&&this.losses.push(this.loss),1==o&&(console.log("Prediction: "),n?console.table(this.outs):console.log(this.outs),console.log("target: "),n?console.table(e):console.log(e),console.log("Loss: ",this.loss))}mutateRandom(t,e){if("number"!=typeof t)return console.error("Dann Error: Dann.mutateRandom(); range argument must be a number."),void console.trace();if(void 0!==e){if("number"!=typeof e)return console.error("Dann Error: Dann.mutateRandom(); probability argument must be a number."),void console.trace()}else e=1;for(let s=0;s<this.Layers.length;s++)this.Layers[s].layer.addRandom(t,e)}mutateAdd(t){if("number"!=typeof t)return console.error("Dann Error: Dann.mutateAdd(); percent argument must be a number."),void console.trace();for(let e=0;e<this.Layers.length;e++)this.Layers[e].layer.addPrecent(t)}applyToModel(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let s=JSON.parse(e[t]),o=new Layer(s.type,s.size,s.actname);this.Layers[t]=o}this.makeWeights();let s=JSON.parse(t.wstr);for(let t=0;t<s.length;t++)this.weights[t].set(JSON.parse(s[t]));let o=JSON.parse(t.bstr);for(let t=0;t<o.length;t++)this.biases[t].set(JSON.parse(o[t]));let r=JSON.parse(t.estr);for(let t=0;t<r.length;t++)this.errors[t].set(JSON.parse(r[t]));let i=JSON.parse(t.gstr);for(let t=0;t<i.length;t++)this.gradients[t].set(JSON.parse(i[t]));this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1]),this.loss=t.loss,this.losses=[],this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,isBrowser?(console.log(""),console.log("Succesfully loaded the Dann Model")):(console.log("[32m",""),console.log("Succesfully loaded the Dann Model"),console.log("[0m",""))}save(t,e){let s,o=!1,r=!1,i=0,n="none";if(void 0!==e&&(void 0!==e.report&&(r=e.report),void 0!==e.test))if("function"==typeof e.test){i=100*(0,e.test)(),n=i+"%"}else console.error("Dann Error: the test option can only be a function."),console.trace();let a=[];for(let t=0;t<this.weights.length;t++)a[t]=JSON.stringify(this.weights[t].matrix);let l=JSON.stringify(a),h=[];for(let t=0;t<this.Layers.length;t++)h[t]=JSON.stringify(this.Layers[t]);let c=JSON.stringify(h),u=[];for(let t=0;t<this.biases.length;t++)u[t]=JSON.stringify(this.biases[t].matrix);let d=JSON.stringify(u),f=[];for(let t=0;t<this.errors.length;t++)f[t]=JSON.stringify(this.errors[t].matrix);let g=JSON.stringify(f),m=[];for(let t=0;t<this.gradients.length;t++)m[t]=JSON.stringify(this.gradients[t].matrix);let p={wstr:l,lstr:c,bstr:d,estr:g,gstr:JSON.stringify(m),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch};if(isBrowser)downloadSTR(p,t);else{if(s="./savedDanns/"+t+"/dannData.json",fs.existsSync(s)&&(o=!0),fs.existsSync("./savedDanns")||fs.mkdirSync("./savedDanns"),fs.existsSync("./savedDanns/"+t)||fs.mkdirSync("./savedDanns/"+t),1==r){let s=[];for(let t=1;t<this.arch.length;t++)s[t-1]=this.Layers[t].actname;let o=[];o.push(["Dann","train report"]),o.push(["Arch: ",this.arch]),o.push(["Acts: ",s]),o.push(["Lr: ",this.lr]),o.push(["Epoch:",this.epoch]),"function"==typeof e.test&&o.push(["Accuracy:",n]),o.push(["Index","AvgLoss"]);for(let t=0;t<this.losses.length;t++)o.push([t+1,this.losses[t]]);w.writeToPath("./savedDanns/"+t+"/report.csv",o).on("error",t=>console.error(t)).on("finish",()=>console.log("saved training report at ./savedDanns/"+t+"/report.csv"))}fs.writeFileSync(s,JSON.stringify(p)),1==o?(console.log("[32m",""),this.log(),console.log("Succesfully overwritten the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m","")):(console.log("[32m",""),this.log(),console.log("Succesfully saved the Dann Model at ./savedDanns/"+t+"/dannData.json "),console.log("[0m",""))}}load(t,e){if(isBrowser)upload(t),"function"==typeof e&&e();else{let e="./savedDanns/"+t+"/dannData.json";if(fs.existsSync(e)){let t=fs.readFileSync(e,"utf8"),s=JSON.parse(t);this.applyToModel(s)}else console.error("Dann Error: file not found"),console.trace()}}log(t){let e=!1,s=!1,o=!1,r=!1,i=!1,n=!1,a=!1,l=!1,h=1e3;if(void 0!==t){if(t.weights&&(e=t.weights),t.gradients&&(s=t.gradients),t.errors&&(o=t.errors),t.biases&&(r=t.biases),t.struct&&(i=t.struct),t.misc&&(n=t.misc),t.table&&(l=t.table),t.layers&&(a=t.layers,i=t.layers),t.details){let l=t.details;s=l,e=l,o=l,r=l,i=l,n=l,a=l}t.decimals&&(t.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),t.decimals=21),h=pow(10,t.decimals))}else i=!0,n=!0;if(0===this.weights.length&&this.makeWeights(),(null==t||void 0!==t&&1==t.details)&&console.log("Dann NeuralNetwork:"),i){console.log(" "),console.log("  Layers:");for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t],s=e.type+" Layer: ",o="";0==t?(s="Input Layer:   ",o="       "):t==e.length-1?(s="Output Layer:  ",o="  ("+e.actname+")"):o="  ("+e.actname+")",console.log("    "+s+e.size+o),a&&console.log(this.Layers[t])}}if(o){console.log(" "),console.log("  Errors:");for(let t=0;t<this.errors.length;t++){let e=Matrix.toArray(this.errors[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;1==l?console.table(s):console.log(s)}}if(s){console.log(" "),console.log("  Gradients:");for(let t=0;t<this.gradients.length;t++){let e=Matrix.toArray(this.gradients[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;1==l?console.table(s):console.log(s)}}if(e){console.log(" "),console.log("  Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:l})}}if(r){console.log(" "),console.log("  Biases:");for(let t=0;t<this.biases.length;t++){let e=Matrix.toArray(this.biases[t]),s=[];for(let t=0;t<e.length;t++)s[t]=round(e[t]*h)/h;1==l?console.table(s):console.log(s)}}n&&(console.log(" "),console.log("  Other Values: "),console.log(" "),console.log("    Learning rate: "+this.lr),console.log("    Loss Function: "+this.lossfunc.name),console.log("    Current Epoch: "+this.epoch),console.log("    Latest Loss: "+this.loss)),console.log(" ")}}let activations={leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d},lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse},poolfuncs={max:max,min:min,avg:avg};"object"==typeof process&&(module.exports={dann:Dann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs});