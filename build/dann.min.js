const isBrowser="object"!=typeof process;let fs,w;function addCDNdependencies(){let e=document.createElement("script");e.setAttribute("type","text/javascript"),e.setAttribute("src","https://cdn.jsdelivr.net/npm/mathjs@8.1.0/lib/browser/math.min.js"),document.head.insertBefore(e,document.head.children[0])}function downloadSTR(e,t){let s="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(e)),r=document.createElement("a");r.setAttribute("href",s),r.setAttribute("download",t+".json"),document.body.appendChild(r),r.click(),r.remove()}function upload(e,t,s){window.addEventListener("load",(function(){let r="";void 0!==s&&(r=","+s.toString());let o=document.createElement("input");o.setAttribute("type","file"),o.setAttribute("id","upload"),o.setAttribute("onChange","clickedUpload("+e+r+")");try{void 0!==t?document.getElementById(t).appendChild(o):document.body.appendChild(o)}catch(e){console.error("Dann Error: the target id specified is not valid")}}))}function clickedUpload(nn,callback){let callfunc=eval(callback),element=document.getElementById("upload"),file=element.files[0],reader=new FileReader,newNN;reader.readAsText(file),reader.onload=function(){if("{"==reader.result[0]){let e=JSON.parse(reader.result);newNN=e,nn.applyToModel(newNN),void 0!==callfunc?callfunc(!1):console.log("Succesfully loaded the file.")}else void 0!==callfunc?callfunc(!0):console.log("Error loading the file.")},reader.onerror=function(){void 0!==callfunc?callfunc(!0):console.log(reader.error)},element.remove()}isBrowser?addCDNdependencies():(fs=require("fs"),require("mathjs"),w=require("@fast-csv/format"));const random=(e,t)=>Math.random(1)*(t-e)+e,exp=e=>Math.exp(e),abs=e=>Math.abs(e),log=e=>Math.log(e),logn=(e,t)=>log(e)/log(t),pow=(e,t)=>Math.pow(e,t),sin=e=>Math.sin(e),cos=e=>Math.cos(e),tan=e=>Math.tan(e),round=e=>Math.round(e),sqrt=e=>Math.sqrt(e),cosh=e=>(exp(e)+exp(-e))/2,sech=e=>1/cosh(e);function sigmoid(e){return 1/(1+exp(-e))}function sigmoid_d(e){let t=sigmoid(e);return t*(1-t)}function leakySigmoid(e){return 1/(1+exp(-e))+e/100}function leakySigmoid_d(e){let t=leakySigmoid(e);return t*(1-t)}function siLU(e){return e/(1+exp(-e))}function siLU_d(e){return(1+exp(-e)+e*exp(-e))/pow(1+exp(-e),2)}function tanH(e){return(exp(e)-exp(-e))/(exp(e)+exp(-e))}function tanH_d(e){return 1-pow(tanH(e),2)}function leakyReLUCapped(e){return e>=0&&e<=6?e:e<0?.1*e:6}function leakyReLUCapped_d(e){return e>=0&&e<=6?1:e<0?.1:0}function leakyReLU(e){return e>=0?1*e:.01*e}function leakyReLU_d(e){return e>=0?1:.01}function reLU(e){return e>=0?1*e:0}function reLU_d(e){return e>=0?1:0}function mae(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=abs(o-i)}return r=s/o,r}function bce(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=o*log(i)+(1-o)*log(1-i)}return r=-s/o,r}function lcl(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=log(cosh(i-o))}return r=s/o,r}function mbe(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){s+=t[r]-e[r]}return r=s/o,r}function mael(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r]-e[r];s+=-o*(exp(-o)-1)/(exp(-o)+1)}return r=s/o,r}function rmse(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=pow(o-i,2)}return r=sqrt(s/o),r}function mce(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=pow(abs(o-i),3)}return r=s/o,r}function mse(e,t){let s=0,r=0,o=t.length;for(let r=0;r<o;r++){let o=t[r],i=e[r];s+=pow(o-i,2)}return r=s/o,r}function max(e){let t=0,s=e.length;for(let r=0;r<s;r++)e[r]>t&&(t=e[r]);return t}function min(e){let t=1/0,s=e.length;for(let r=0;r<s;r++)e[r]<t&&(t=e[r]);return t}function avg(e){let t=0,s=e.length;for(let r=0;r<s;r++)t+=e[r];return t/s}class Matrix{constructor(e,t){this.rows=e,this.cols=t,this.matrix=Matrix.make(e,t)}static toArray(e){let t=[];if(1==e.cols)for(let s=0;s<e.rows;s++)t[s]=e.matrix[s][0];return t}static fromArray(e){let t=new Matrix(e.length,1);for(let s=0;s<e.length;s++)t.matrix[s][0]=e[s];return t}static transpose(e){let t=new Matrix(e.cols,e.rows);for(let s=0;s<e.rows;s++)for(let r=0;r<e.cols;r++)t.matrix[r][s]=e.matrix[s][r];return t}static map(e,t){for(let s=0;s<e.rows;s++)for(let r=0;r<e.cols;r++){let o=e.matrix[s][r];e.matrix[s][r]=t(o)}return e}static addition(e,t){let s=e,r=t,o=new Matrix(s.rows,s.cols);if(s.rows===r.rows&&s.cols===r.cols){for(let e=0;e<o.rows;e++)for(let t=0;t<o.cols;t++)o.matrix[e][t]=s.matrix[e][t]-r.matrix[e][t];return o}}static subtract(e,t){let s=e,r=t,o=new Matrix(s.rows,s.cols);if(s instanceof Matrix&&r instanceof Matrix)for(let e=0;e<o.rows;e++)for(let t=0;t<o.cols;t++)o.matrix[e][t]=s.matrix[e][t]-r.matrix[e][t];return o}static multiply(e,t,s){let r="cpu";if(void 0!==s&&s.mode&&(r=s.mode),"cpu"!=r)return"gpu"==r?(console.log("gpu coming soon"),r="cpu",Matrix.multiply(e,t)):(console.error("Dann Error: mode specified is not valid"),void console.trace());{let s=e,r=t,o=new Matrix(s.rows,r.cols);if(e instanceof Matrix&&t instanceof Matrix){if(s.cols!==r.rows)return console.log(s,r),console.error("not compatible"),void console.trace();for(let e=0;e<o.rows;e++)for(let t=0;t<o.cols;t++){let i=0;for(let o=0;o<s.cols;o++)i+=s.matrix[e][o]*r.matrix[o][t];o.matrix[e][t]=i}return o}}}static make(e,t){let s=[];for(let r=0;r<e;r++){s[r]=[];for(let e=0;e<t;e++)s[r][e]=0}return s}insert(e,t,s){return"number"!=typeof e?(console.error('Dann error: first "value" argument is not a number'),void console.trace()):"number"!=typeof t?(console.error('Dann error: second "x" argument is not a number'),void console.trace()):"number"!=typeof s?(console.error('Dann error: third "y" argument is not a number'),void console.trace()):void(t<this.cols&&s<this.rows?this.matrix[s][t]=e:(console.error("Dann error: x,y arguments exceed the matrix dimensions."),console.trace()))}addRandom(e,t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.cols;r++){let o=this.matrix[s][r];random(0,1)<t&&(this.matrix[s][r]+=o*random(-e,e))}}addPrecent(e){for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++){let r=this.matrix[t][s];this.matrix[t][s]+=r*e}}set(e){if("number"!=typeof e.length||"number"!=typeof e[0].length||"object"!=typeof e)return console.error("Dann error: the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]"),void console.trace();this.matrix=e,this.rows=e.length,this.cols=e[0].length}add(e){if(e instanceof Matrix){if(this.rows!==e.rows||this.cols!==e.cols)return;for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.matrix[t][s]+=e.matrix[t][s]}else for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.matrix[t][s]+=e}sub(e){for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.matrix[t][s]-=e}mult(e){if(e instanceof Matrix){if(this.rows!==e.rows||this.cols!==e.cols)return void console.log("rows of A must match rows of B");for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.matrix[t][s]*=e.matrix[t][s]}else for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.matrix[t][s]*=e}log(e){let t=1e3,s=!1;void 0!==e&&(e.decimals&&(t=pow(10,e.decimals)),e.table&&(s=e.table));let r=new Matrix(this.rows,this.cols);for(let e=0;e<this.rows;e++)for(let s=0;s<this.cols;s++){let o=this.matrix[e][s];r.insert(round(o*t)/t,s,e)}s?console.table(r.matrix):console.log(r)}initiate(e){let t=0;if(void 0!==e){if("number"!=typeof e)return console.error("Dann error: the value entered as an argument is not a number"),void console.trace();t=e}for(let e=0;e<this.matrix.length;e++)for(let s=0;s<this.matrix[e].length;s++)this.matrix[e][s]=t}map(e){for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++){let r=this.matrix[t][s];this.matrix[t][s]=e(r)}}randomize(e,t){for(let s=0;s<this.matrix.length;s++)for(let r=0;r<this.matrix[s].length;r++)this.matrix[s][r]=random(e,t)}}class Layer{constructor(e,t,s,r,o,i){if(this.type=e,this.subtype=Layer.getSubtype(e),"hidden"==this.type||"output"==this.type){this.size=t;let e=Layer.stringTofunc(s);this.setFunc(e),this.layer=new Matrix(this.size,1)}else if("input"==this.type)this.size=t,this.layer=new Matrix(this.size,1);else if("pool"==this.subtype){if(this.stride=r,this.sampleSize=s,this.inputSize=t,void 0!==o&&void 0!==i)this.sizeX=o,this.sizeY=i;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=Layer.getPoolOutputLength(t,s,r,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,n=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&n!==Math.floor(n))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1);let a=Layer.getPrefix(this.type,4);this.poolfunc=poolfuncs[a],this.downsample=function(e,t,s){this.input=Matrix.fromArray(e);let r=Layer.selectPools(e,t,s,this.sizeX,this.sizeY),o=[];for(let e=0;e<r.length;e++)o[e]=this.poolfunc(r[e]);return this.layer=Matrix.fromArray(o),o},this.feed=function(e,t){let s=!1,r=!1,o=this.sampleSize,i=this.stride;if(void 0!==t&&(t.log&&(s=t.log),t.table&&(r=t.table)),e.length!==this.inputSize)return console.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has."),void console.trace();{let t=this.downsample(e,o,i);return s&&(r?console.table(t):console.log(t)),t}}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())}static stringTofunc(e){let t,s,r=e,o=r+"_d";if(isBrowser?(t=window[r],s=window[o]):(t=activations[r],s=activations[o]),void 0!==t)return void 0!==s?{name:r,name_d:o,func:t,func_d:s}:(console.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+e+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'."),void console.trace());console.error("Dann Error: the activation function '"+e+"' is not a valid activation function. The activation function was set to the default 'sigmoid'."),console.trace()}static getPrefix(e,t){let s=e.length;return e.slice(0,s-4)}static getSubtype(e){let t=e.length,s=e.slice(t-4,t);return"pool"==s?s:e}static getSqIndex(e,t,s){return e*s+t}static selectPools(e,t,s,r,o){e.length;if(r!==Math.floor(r))return;if(r/s!==Math.floor(r/s))return;let i=[];for(let n=0;n+t<=o;n+=s)for(let o=0;o+t<=r;o+=s){let s=[];for(let i=0;i<t;i++)for(let a=0;a<t;a++)s.push(e[Layer.getSqIndex(r,a+o,i+n)]);i.push(s)}return i}static getPoolOutputLength(e,t,s,r,o){return((r-t)/s+1)*((o-t)/s+1)}setAct(e){let t=Layer.stringTofunc(e);this.setFunc(t)}setFunc(e){void 0!==e&&(this.actname=e.name,this.actname_d=e.name_d,this.actfunc=e.func,this.actfunc_d=e.func_d)}log(){console.log(this)}}class Dann{constructor(e=1,t=1){this.i=e,this.inputs=new Layer("input",e),this.o=t,this.outputs=new Layer("output",t,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.outs=[],this.loss=0,this.losses=[],this.lr=.001,this.arch=[e,t],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name}setLossFunction(e){let t=lossfuncs[e];if(null==t)return"string"==typeof e?(console.error("Dann Error: '"+e+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default."),void console.trace()):(console.error("Dann Error: Did not detect string value, as a result, the loss function is set to 'mse' by default."),void console.trace());this.lossfunc_s=e,this.lossfunc=t}outputActivation(e){if(null==activations[e]&&!isBrowser)return"string"==typeof e?(console.error("Dann Error: '"+e+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),void console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),void console.trace());this.Layers[this.Layers.length-1].setAct(e)}makeWeights(e,t){let s=-1,r=1;void 0!==e&&void 0!==t&&(s=e,r=t);for(let e=0;e<this.Layers.length-1;e++){let t=this.Layers[e],o=this.Layers[e+1],i=new Matrix(o.layer.rows,t.layer.rows),n=new Matrix(o.layer.rows,1);if(i.randomize(s,r),n.randomize(1,-1),this.weights[e]=i,this.biases[e]=n,this.errors[e]=new Matrix(o.layer.rows,1),this.gradients[e]=new Matrix(o.layer.rows,1),null==o.actfunc){let e=Layer.stringTofunc("sigmoid");o.setFunc(e)}}for(let e=0;e<this.Layers.length;e++){let t=this.Layers[e];this.arch[e]=t.layer.rows}}addHiddenLayer(e,t){if(null==activations[t])return"string"==typeof t?(console.error("Dann Error: '"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default."),void console.trace()):(console.error("Dann Error: Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default."),void console.trace());let s=new Layer("hidden",e,t);this.Layers.splice(this.Layers.length-1,0,s)}feedForward(e,t){let s=!1,r="cpu",o=!1,i=!1,n=1e3;if(void 0!==t&&(s=void 0!==t.log&&t.log,void 0!==t.decimals&&(t.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),t.decimals=21),n=pow(10,t.decimals),i=!0),void 0!==t.table&&(o=t.table),void 0!==t.mode?(r=t.mode,"gpu"==r&&(console.warn("Gpu support in the works."),r="cpu")):r="cpu"),e.length!=this.i){for(let e=0;e<this.o;e++)this.outs[e]=0;return console.error("Dann Error: The input array length does not match the number of inputs the dannjs model has."),console.trace(),this.outs}this.Layers[0].layer=Matrix.fromArray(e),0===this.weights.length&&(console.warn("Dann Warning: The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers."),this.makeWeights());for(let e=0;e<this.weights.length;e++){let t=this.Layers[e],s=this.Layers[e+1];s.layer=Matrix.multiply(this.weights[e],t.layer),s.layer.add(this.biases[e]),s.layer.map(s.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let a=this.outs;return 1==s&&(1==i&&(a=a.map(e=>round(e*n)/n)),1==o?(console.log("Prediction: "),console.table(a)):console.log("Prediction: ",a)),a}backpropagate(e,t,s){let r=!1,o="cpu",i=!1,n=!1;void 0!==s&&(r=void 0!==s.log&&s.log,void 0!==s.table&&(n=s.table),void 0!==s.mode?(o=s.mode,"gpu"==o&&console.log("gpu version coming soon")):o="cpu",i=void 0===s.saveLoss||s.saveLoss);let a=new Matrix(0,0);if(t.length!=this.o)return console.error("Dann Error: The target array length does not match the number of ouputs the dannjs model has."),void console.trace();if(a=Matrix.fromArray(t),"number"!=typeof this.lr)return console.error("Dann Error: The learning rate specified (Dann.lr property) is not a number."),void console.trace();this.outs=this.feedForward(e,{log:!1,mode:o}),this.errors[this.errors.length-1]=Matrix.subtract(a,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr);for(let e=this.weights.length-1;e>0;e--){let t=Matrix.transpose(this.Layers[e].layer),s=Matrix.multiply(this.gradients[e],t);this.weights[e].add(s),this.biases[e].add(this.gradients[e]);let r=Matrix.transpose(this.weights[e]);this.errors[e-1]=Matrix.multiply(r,this.errors[e]),this.gradients[e-1]=Matrix.map(this.Layers[e].layer,this.Layers[e].actfunc_d),this.gradients[e-1].mult(this.errors[e-1]),this.gradients[e-1].mult(this.lr)}let l=Matrix.transpose(this.Layers[0].layer),c=Matrix.multiply(this.gradients[0],l);this.weights[0].add(c),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,t),1==i&&this.losses.push(this.loss),1==r&&(console.log("Prediction: "),n?console.table(this.outs):console.log(this.outs),console.log("target: "),n?console.table(t):console.log(t),console.log("Loss: ",this.loss))}mutateRandom(e,t){if("number"!=typeof e)return console.error("Dann Error: Dann.mutateRandom(); range argument must be a number."),void console.trace();if(void 0!==t){if("number"!=typeof t)return console.error("Dann Error: Dann.mutateRandom(); probability argument must be a number."),void console.trace()}else t=1;for(let s=0;s<this.Layers.length;s++)this.Layers[s].layer.addRandom(e,t)}mutateAdd(e){if("number"!=typeof e)return console.error("Dann Error: Dann.mutateAdd(); percent argument must be a number."),void console.trace();for(let t=0;t<this.Layers.length;t++)this.Layers[t].layer.addPrecent(e)}static createFromObject(e){const t=new Dann;return t.applyToModel(e),t}dataObject(){let e=[];for(let t=0;t<this.weights.length;t++)e[t]=JSON.stringify(this.weights[t].matrix);let t=JSON.stringify(e),s=[];for(let e=0;e<this.Layers.length;e++)s[e]=JSON.stringify(this.Layers[e]);let r=JSON.stringify(s),o=[];for(let e=0;e<this.biases.length;e++)o[e]=JSON.stringify(this.biases[e].matrix);let i=JSON.stringify(o),n=[];for(let e=0;e<this.errors.length;e++)n[e]=JSON.stringify(this.errors[e].matrix);let a=JSON.stringify(n),l=[];for(let e=0;e<this.gradients.length;e++)l[e]=JSON.stringify(this.gradients[e].matrix);return{wstr:t,lstr:r,bstr:i,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch}}save(e,t){let s,r=!1,o=!1,i=0,n="none";if(void 0!==t&&(void 0!==t.report&&(o=t.report),void 0!==t.test))if("function"==typeof t.test){i=100*(0,t.test)(),n=i+"%"}else console.error("Dann Error: the test option can only be a function."),console.trace();let a=this.dataObject();if(isBrowser)downloadSTR(a,e);else{if(s="./savedDanns/"+e+"/dannData.json",fs.existsSync(s)&&(r=!0),fs.existsSync("./savedDanns")||fs.mkdirSync("./savedDanns"),fs.existsSync("./savedDanns/"+e)||fs.mkdirSync("./savedDanns/"+e),1==o){let s=[];for(let e=1;e<this.arch.length;e++)s[e-1]=this.Layers[e].actname;let r=[];r.push(["Dann","train report"]),r.push(["Arch: ",this.arch]),r.push(["Acts: ",s]),r.push(["Lr: ",this.lr]),r.push(["Epoch:",this.epoch]),"function"==typeof t.test&&r.push(["Accuracy:",n]),r.push(["Index","AvgLoss"]);for(let e=0;e<this.losses.length;e++)r.push([e+1,this.losses[e]]);w.writeToPath("./savedDanns/"+e+"/report.csv",r).on("error",e=>console.error(e)).on("finish",()=>console.log("saved training report at ./savedDanns/"+e+"/report.csv"))}fs.writeFileSync(s,JSON.stringify(a)),1==r?(console.log("[32m",""),this.log(),console.log("Succesfully overwritten the Dann Model at ./savedDanns/"+e+"/dannData.json "),console.log("[0m","")):(console.log("[32m",""),this.log(),console.log("Succesfully saved the Dann Model at ./savedDanns/"+e+"/dannData.json "),console.log("[0m",""))}}applyToModel(e){this.i=e.arch[0],this.inputs=new Matrix(this.i,1),this.o=e.arch[e.arch.length-1],this.outputs=new Matrix(this.o,1);let t=JSON.parse(e.lstr);for(let e=0;e<t.length;e++){let s=JSON.parse(t[e]),r=new Layer(s.type,s.size,s.actname);this.Layers[e]=r}this.makeWeights();let s=JSON.parse(e.wstr);for(let e=0;e<s.length;e++)this.weights[e].set(JSON.parse(s[e]));let r=JSON.parse(e.bstr);for(let e=0;e<r.length;e++)this.biases[e].set(JSON.parse(r[e]));let o=JSON.parse(e.estr);for(let e=0;e<o.length;e++)this.errors[e].set(JSON.parse(o[e]));let i=JSON.parse(e.gstr);for(let e=0;e<i.length;e++)this.gradients[e].set(JSON.parse(i[e]));return this.lossfunc_s=e.lf,this.lossfunc=isBrowser?window[e.lf]:lossfuncs[e.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1]),this.loss=e.loss,this.losses=[],this.lr=e.lrate,this.arch=e.arch,this.epoch=e.e,this}static createModelFromJSON(e,t){let s=new Dann(0,0);return s.applyToModel(JSON.stringify(t)),Object.assign(s,e)}load(e,t,s){if(isBrowser)upload(e,t,s);else{let s="./savedDanns/"+e+"/dannData.json";if(fs.existsSync(s)){let e=fs.readFileSync(s,"utf8"),r=JSON.parse(e);if(this.applyToModel(r),"function"==typeof t)t(!1);else{let e=typeof t;console.error("Dann Error: callback specified is not a function, the funtion recieved a "+e+" instead"),console.trace()}}else if("function"==typeof t)t(!0);else if("function"!=typeof t){let e=typeof t;console.error("Dann Error: callback specified is not a function, the funtion recieved a "+e+" instead"),console.trace()}else console.error("Dann Error: file not found"),console.trace()}}log(e){let t=!1,s=!1,r=!1,o=!1,i=!1,n=!1,a=!1,l=!1,c=1e3;if(void 0!==e){if(e.weights&&(t=e.weights),e.gradients&&(s=e.gradients),e.errors&&(r=e.errors),e.biases&&(o=e.biases),e.struct&&(i=e.struct),e.misc&&(n=e.misc),e.table&&(l=e.table),e.layers&&(a=e.layers,i=e.layers),e.details){let l=e.details;s=l,t=l,r=l,o=l,i=l,n=l,a=l}e.decimals&&(e.decimals>21&&(console.error("Dann Error: Maximum number of decimals is 21."),console.trace(),e.decimals=21),c=pow(10,e.decimals))}else i=!0,n=!0;if(0===this.weights.length&&this.makeWeights(),(null==e||void 0!==e&&1==e.details)&&console.log("Dann NeuralNetwork:"),i){console.log(" "),console.log("  Layers:");for(let e=0;e<this.Layers.length;e++){let t=this.Layers[e],s=t.type+" Layer: ",r="";0==e?(s="Input Layer:   ",r="       "):e==t.length-1?(s="Output Layer:  ",r="  ("+t.actname+")"):r="  ("+t.actname+")",console.log("    "+s+t.size+r),a&&console.log(this.Layers[e])}}if(r){console.log(" "),console.log("  Errors:");for(let e=0;e<this.errors.length;e++){let t=Matrix.toArray(this.errors[e]),s=[];for(let e=0;e<t.length;e++)s[e]=round(t[e]*c)/c;console.log(s)}}if(s){console.log(" "),console.log("  Gradients:");for(let e=0;e<this.gradients.length;e++){let t=Matrix.toArray(this.gradients[e]),s=[];for(let e=0;e<t.length;e++)s[e]=round(t[e]*c)/c;console.log(s)}}if(t){console.log(" "),console.log("  Weights:");for(let t=0;t<this.weights.length;t++){this.weights[t].log({decimals:e.decimals,table:l})}}if(o){console.log(" "),console.log("  Biases:");for(let e=0;e<this.biases.length;e++){let t=Matrix.toArray(this.biases[e]),s=[];for(let e=0;e<t.length;e++)s[e]=round(t[e]*c)/c;console.log(s)}}n&&(console.log(" "),console.log("  Other Values: "),console.log(" "),console.log("    Learning rate: "+this.lr),console.log("    Loss Function: "+this.lossfunc.name),console.log("    Current Epoch: "+this.epoch),console.log("    Latest Loss: "+this.loss)),console.log(" ")}}let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d},lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael},poolfuncs={max:max,min:min,avg:avg};isBrowser||(module.exports={dann:Dann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeBinary:makeBinary});